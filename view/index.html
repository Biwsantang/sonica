<!DOCTYPE html>
<html>

<head>
    <title>TEST WEBSOCKET</title>
    <script type="text/javascript" src="js/app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/kalmanjs@1.1.0/lib/kalman.min.js"></script>
</head>

<body>
    <script src="js/three.js"></script>
    <script type="module">
        //console.log(server_cube);
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.120.1/build/three.module.js';
        import Stats from 'https://cdn.jsdelivr.net/npm/three@0.120.1/examples/jsm/libs/stats.module.min.js';
        import { STLLoader } from 'https://cdn.jsdelivr.net/npm/three@0.120.1/examples/jsm/loaders/STLLoader.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.120.1/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true

	var model;

        const loader = new STLLoader()
        loader.load(
            'models/Ultrasonic_sensor_triple_mount.stl',
            function (geometry) {
                const material = new THREE.MeshBasicMaterial({
                    color: 0x0000ff
                });
                const mesh = new THREE.Mesh(geometry, material)
                mesh.rotation.x = 135
                mesh.position.x = 0
                mesh.position.y = 0
                mesh.position.z = 2
                mesh.scale.x = 0.1
                mesh.scale.y = 0.1
                mesh.scale.z = 0.1
                scene.add(mesh)

		console.log(mesh);
		model = mesh;	
		console.log(model);
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total) * 100 + '% loaded')
            },
            (error) => {
                console.log(error)
            }
        )

        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshBasicMaterial({
            color: 0x00ff00
        });

        const cube = [new THREE.Mesh(geometry, material), new THREE.Mesh(geometry, material), new THREE.Mesh(geometry,
            material)];

        scene.add(cube[0]);
        scene.add(cube[1]);
        scene.add(cube[2]);

        const white = new THREE.LineDashedMaterial({
	        color: 0xffffff
        });

	const line_geometry = [new THREE.Geometry(), new THREE.Geometry(), new THREE.Geometry()];

        const line = [new THREE.Line( line_geometry[0], white ), new THREE.Line( line_geometry[1], white ), new THREE.Line( line_geometry[2], white )];

        scene.add( line[0] );
	scene.add( line[1] );
	scene.add( line[2] );


        camera.position.z = 50;

	var kf_L = new KalmanFilter();
	var kf_C = new KalmanFilter();
	var kf_R = new KalmanFilter();

        const animate = function () {
            requestAnimationFrame(animate);

	    var cube_L = kf_L.filter(server_cube[0] > 200 ? 200 : server_cube[0])
	    console.log(cube_L)
            cube[0].position.x = cube_L * Math.sin(Math.PI * 2 * -45 / 360) - 4.5;
            cube[0].position.y = cube_L * Math.cos(Math.PI * 2 * -45 / 360) - 2;

	    var cube_C = kf_C.filter(server_cube[1] > 200 ? 200 : server_cube[1])
	    console.log(cube_C)
            cube[1].position.x = cube_C * Math.sin(Math.PI * 2 * 0 / 360);
            cube[1].position.y = cube_C * Math.cos(Math.PI * 2 * 0 / 360);

	    var cube_R = kf_R.filter(server_cube[2] > 200 ? 200 : server_cube[2])
	    console.log(cube_R)
            cube[2].position.x = cube_R * Math.sin(Math.PI * 2 * 45 / 360) + 4.5;
            cube[2].position.y = cube_R * Math.cos(Math.PI * 2 * 45 / 360) - 2;

	    for (const i of line_geometry.keys()) {
		    line_geometry[i].vertices.push(
			cube[i].position,
			//model.position
            new THREE.Vector3(model.position.x,model.position.y-6.25,model.position.z)			
		    );
		    line_geometry[i].verticesNeedUpdate = true;
	    }


            renderer.render(scene, camera);
        };

        animate();
    </script>
</body>

</html>
